# Plan: Popover Component

## Objective

Create a Popover component for click-triggered overlays with positioning.

## Tasks

### Task 1: Create Popover Component

Create `packages/react/src/components/Popover/`:

**Popover.tsx:**
```tsx
import { type ReactNode, type ReactElement, useState, useRef, useEffect, cloneElement } from "react";
import { createPortal } from "react-dom";
import clsx from "clsx";
import { Box } from "@/components/Box/Box";
import styles from "./popover.module.css";

export type PopoverPlacement = "top" | "bottom" | "left" | "right";

export type PopoverProps = {
  /** Popover content */
  content: ReactNode;
  /** Placement of popover */
  placement?: PopoverPlacement;
  /** Close on outside click */
  closeOnBlur?: boolean;
  /** Additional class name */
  className?: string;
  /** Trigger element */
  children: ReactElement;
};

export type PopoverContentProps = {
  className?: string;
  children?: ReactNode;
};

export type PopoverHeaderProps = {
  className?: string;
  children?: ReactNode;
};

export type PopoverBodyProps = {
  className?: string;
  children?: ReactNode;
};

export function Popover({
  content,
  placement = "bottom",
  closeOnBlur = true,
  className,
  children,
}: PopoverProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const triggerRef = useRef<HTMLElement>(null);
  const popoverRef = useRef<HTMLDivElement>(null);

  const updatePosition = () => {
    if (!triggerRef.current || !popoverRef.current) return;

    const triggerRect = triggerRef.current.getBoundingClientRect();
    const popoverRect = popoverRef.current.getBoundingClientRect();
    const gap = 8;

    let top = 0;
    let left = 0;

    switch (placement) {
      case "top":
        top = triggerRect.top - popoverRect.height - gap;
        left = triggerRect.left + (triggerRect.width - popoverRect.width) / 2;
        break;
      case "bottom":
        top = triggerRect.bottom + gap;
        left = triggerRect.left + (triggerRect.width - popoverRect.width) / 2;
        break;
      case "left":
        top = triggerRect.top + (triggerRect.height - popoverRect.height) / 2;
        left = triggerRect.left - popoverRect.width - gap;
        break;
      case "right":
        top = triggerRect.top + (triggerRect.height - popoverRect.height) / 2;
        left = triggerRect.right + gap;
        break;
    }

    setPosition({ top: top + window.scrollY, left: left + window.scrollX });
  };

  useEffect(() => {
    if (isOpen) updatePosition();
  }, [isOpen]);

  // Close on outside click
  useEffect(() => {
    if (!isOpen || !closeOnBlur) return;

    const handleClick = (e: MouseEvent) => {
      if (
        triggerRef.current?.contains(e.target as Node) ||
        popoverRef.current?.contains(e.target as Node)
      ) return;
      setIsOpen(false);
    };

    document.addEventListener("click", handleClick);
    return () => document.removeEventListener("click", handleClick);
  }, [isOpen, closeOnBlur]);

  // Close on Escape
  useEffect(() => {
    if (!isOpen) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === "Escape") setIsOpen(false);
    };

    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [isOpen]);

  const trigger = cloneElement(children, {
    ref: triggerRef,
    onClick: (e: React.MouseEvent) => {
      children.props.onClick?.(e);
      setIsOpen(!isOpen);
    },
    "aria-expanded": isOpen,
    "aria-haspopup": "dialog",
  });

  return (
    <>
      {trigger}
      {isOpen && createPortal(
        <Box
          ref={popoverRef}
          position="absolute"
          bg="surface"
          border="thin"
          borderColor="border"
          rounded="md"
          shadow="lg"
          zIndex="dropdown"
          minW="200px"
          className={clsx(styles.popover, className)}
          style={{ top: position.top, left: position.left }}
          role="dialog"
        >
          {content}
        </Box>,
        document.body
      )}
    </>
  );
}

export function PopoverHeader({ className, children }: PopoverHeaderProps) {
  return (
    <Box
      px={4}
      py={3}
      borderBottom="thin"
      borderColor="border"
      fontWeight="medium"
      className={clsx(styles.header, className)}
    >
      {children}
    </Box>
  );
}

export function PopoverBody({ className, children }: PopoverBodyProps) {
  return (
    <Box px={4} py={3} className={clsx(styles.body, className)}>
      {children}
    </Box>
  );
}
```

**popover.module.css:**
```css
.popover {
  /* Popover styles */
}

.header {
  /* Header styles */
}

.body {
  /* Body styles */
}
```

**index.tsx:**
```tsx
export { Popover, PopoverHeader, PopoverBody } from "./Popover";
export type {
  PopoverPlacement,
  PopoverProps,
  PopoverHeaderProps,
  PopoverBodyProps,
} from "./Popover";
```

### Task 2: Export Popover and Verify Build

1. Add exports to `packages/react/src/index.tsx`
2. Run build to verify

## Verification

- [ ] Popover toggles on click
- [ ] Outside click closes popover
- [ ] Escape key closes popover
- [ ] All placements work
- [ ] Build passes

## Output

- `packages/react/src/components/Popover/Popover.tsx`
- `packages/react/src/components/Popover/popover.module.css`
- `packages/react/src/components/Popover/index.tsx`
